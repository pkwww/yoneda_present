#import "import.typ":*

== Functor
#fancy.definition(title: "Functor")[
  A (covariant) functor $F: cal(C) -> cal(D)$ from $cal(C)$ to $cal(D)$ consists of
  + for each object $X in cal(C)$, an object $F(X) in cal(D)$
  + for each morphism $f:X -> Y$ in $cal(C)$, a morphism $F(f): F(X) -> F(Y)$ in $cal(D)$. (In programming, this is known as `fmap`)
  satisfying the functorial laws
  + $F(id_X) = id_(F(X))$
  + $F(f compose g) = F(f) compose F(g)$
]
#fancy.definition(title: "Contravariant")[
  A contravariant functor $F: cal(C) -> cal(D)$ is similar but with for $f: X -> Y$,
  + $F(f): F(Y) -> F(X)$
  + $F(f compose g) = F(g) compose F(f)$
  which is just a ordinary covariant functor with $cal(C)^"op" -> cal(D)$. Howevery, we usually say "a contravariant functor $F: cal(C)^"op" -> cal(D)$" to emphasize the contravariance.
]

#property[
  Functors preserve isomorphisms. That is, if $F: cal(C) -> cal(D)$ is a functor and $f: X -> Y$ is an isomorphism in $cal(C)$, then $F(f): F(X) -> F(Y)$ is an isomorphism in $cal(D)$.
]
#proof[
  Let $g: Y -> X$ be the inverse of $f$. Then $F(f) compose F(g) = F(f compose g) = F(id_Y) = id_(F(Y))$ and similarly $F(g) compose F(f) = id_(F(X))$. Thus, $F(g)$ is the inverse of $F(f)$.
]
#v(0.5em)
#example[
  Let $sans(bold(B)G), sans(bold(B)H)$ be two groups (viewed as categories). A functor $F: sans(bold(B)G) -> sans(bold(B)H)$ consists of
  + the single object $star$ maps to the single object $star$
  + each morphism $g in sans(bold(B)G)(star,star) = G$ maps to some morphism $F(g): star -> star$ in $sans(bold(B)H)$, which is just an element $h in H$.
  The functoriality make sure that $F(id_star) = id_star$ and $F(g_1 g_2) = F(g_1) F(g_2)$, which suggest that $F$ is just a group homomorphism.
]

#example[
  Let $sans(bold(B)G)$ be a group (viewed as category). A functor $F: sans(bold(B)G) -> sans("Set")$ consists of
  + the single object $star$ maps to some object $X$ in $sans("Set")$
  + each morphism $g in sans(bold(B)G)(star,star) = G$ maps to some morphism $F(g): X -> X$ in $sans("Set")$
  This means that $F$ picks out a set $X$ together with an (left) action of $G$ on $X$. Such a functor is called a (left)-$G$-set. A contravariant functor will define a right-$G$-set.
]

#example[
  A forgetful functor "forget some structure" from one category to another. For example,
  - $U: sans("Grp") -> sans("Set")$ maps each group $G$ to the set $G$, and each group homomorphism to being set theoretic function between sets.
  - $U: sans("AbGrp") -> sans("Grp")$ forgets the commutative structure, but keep the group structure.
  A free functor constructs free (the most general) objects. For example,
  - $F: sans("Set") -> sans("Grp")$ maps each set $X$ to the free group generated by $X$.
]

#example[
  The contravariant power set functor $P: sans("Set")^"op" -> sans("Set")$ maps
  + each set $X$ to its power set $P(X)$
  + each function $f: X -> Y$ to the preimage function $P(f): P(Y) -> P(X)$ defined by $P(f)(S) = f^(-1)(S)$ for each subset $S subset.eq Y$.
  The contravariant open set functor $O: sans("Top")^"op" -> sans("Set")$ is defined similarly, mapping each topological space to its set of open sets.
]

#example[
  The contravariant dual vector space functor $(-)^*: sans("Vect"_k)^"op" -> sans("Vect"_k)$ maps
  + each vector space $V$ to its dual space $V^* = "Hom"(V, k)$
  + each linear transformation $f: V -> W$ to the dual map $f^*: W^* -> V^*$ defined by $f^*(phi) = phi compose f$ for each $phi in W^* = (W -> k)$.
  functoriality is checked as $(f^* compose g^*)(phi) = (phi compose g) compose f = phi compose (g compose f) = (g compose f)^* (phi)$
]

#fancy.definition(title: "Hom functor")[
  The Hom functor $"Hom"(A, -): cal(C) -> sans("Set")$ or simply $h_A$ for a fixed object $A in cal(C)$ maps
  + each object $X in cal(C)$ to the hom set $"Hom"(A, X)$. \ (explicit typing: $X -> (A -> X)$)
  + each morphism $f: X -> Y$ to the function 
  $ "Hom"(A, f)&: "Hom"(A, X) -> "Hom"(A, Y) \ "Hom"(A, f) &= f compose - $  (explicit typing: $(X -> Y) -> (A -> X) -> (A -> Y)$)

  Similarly, we have the contravariant Hom functor $h^X = "Hom"(-, X): cal(C)^"op" -> sans("Set")$ mapping each morphism $f: A -> B$ to the function 
  $ "Hom"(f, X)&: "Hom"(B, X) -> "Hom"(A, X) \ "Hom"(f, X) &= - compose f $
  We can write more compactly as $h_(A)(X), h_(A)(f), h^(X)(A), h^(X)(f)$.
]
#fancy.definition(title: "Product category")[
  Give two category $cal(C)$ and $cal(D)$, their product category $cal(C) times cal(D)$ consists of
  + objects: pairs $(c, d)$ where $c in cal(C)$ and $d in cal(D)$
  + morphisms: pairs $(f, g): (c, d) -> (c', d')$ where $f: c -> c'$ in $cal(C)$ and $g: d -> d'$ in $cal(D)$
  + composition: defined componentwise, $(f', g') compose (f, g) = (f' compose f, g' compose g)$
  + identities: $(id_c, id_d)$ for each object $(c, d)$
]
#definition(title: "Hom bifunctor")[
  Define $"Hom"(-, -): cal(C)^"op" times cal(C) -> sans("Set")$ by
  + objects: $(A, X) mapsto "Hom"(A, X)$
  + morphisms: for a pair $(f, h): (A' -> A, X -> X')$ maps to $"Hom"(A, X) -> "Hom"(A', X')$ by $g mapsto h compose g compose f$
]
#note-box[
  The image of $F: cal(C) -> cal(D)$ is not necessarily a subcategory of $cal(D)$. Idea: when $c_1, c_2$ both map to the same object $d$, then for any two $c_1 -> c_2$, their images are both morphisms $d -> d$ which is composable, but the sources cannot be composed since they don't have matching domain and codomain.
]