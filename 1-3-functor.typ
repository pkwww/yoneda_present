#import "import.typ":*

== Functor
#fancy.definition(title: "Functor")[
  A (covariant) functor $F: calc -> cal(D)$ from $calc$ to $cal(D)$ consists of
  + for each object $X in calc$, an object $F(X) in cal(D)$
  + for each morphism $f:X -> Y$ in $calc$, a morphism $F(f): F(X) -> F(Y)$ in $cal(D)$. (In programming, this is known as `fmap`)
  satisfying the functorial laws
  + $F(id_X) = id_(F(X))$
  + $F(f compose g) = F(f) compose F(g)$
]
#fancy.definition(title: "Contravariant")[
  A contravariant functor $F: calc -> cal(D)$ is similar but with for $f: X -> Y$,
  + $F(f): F(Y) -> F(X)$
  + $F(f compose g) = F(g) compose F(f)$
  which is just a ordinary covariant functor with $calc^op -> cal(D)$. Howevery, we usually say "a contravariant functor $F: calc^op -> cal(D)$" to emphasize the contravariance.
]

#property[
  Functors preserve isomorphisms. That is, if $F: calc -> cal(D)$ is a functor and $f: X -> Y$ is an isomorphism in $calc$, then $F(f): F(X) -> F(Y)$ is an isomorphism in $cal(D)$.
]<prop:functor-preserves-iso>
#proof[
  Let $g: Y -> X$ be the inverse of $f$. Then $F(f) compose F(g) = F(f compose g) = F(id_Y) = id_(F(Y))$ and similarly $F(g) compose F(f) = id_(F(X))$. Thus, $F(g)$ is the inverse of $F(f)$.
]
#v(0.5em)
#example[
  Let $unlp(G), unlp(H)$ be two groups (viewed as categories). A functor $F: unlp(G) -> unlp(H)$ consists of
  + the single object $star$ maps to the single object $star$
  + each morphism $g in unlp(G)(star,star) = G$ maps to some morphism $F(g): star -> star$ in $unlp(H)$, which is just an element $h in H$.
  The functoriality make sure that $F(id_star) = id_star$ and $F(g_1 g_2) = F(g_1) F(g_2)$, which suggest that $F$ is just a group homomorphism.
]

#example[
  Let $unlp(G)$ be a group (viewed as category). A functor $F: unlp(G) -> Set$ consists of
  + the single object $star$ maps to some object $X$ in $Set$
  + each morphism $g in unlp(G)(star,star) = G$ maps to some morphism $F(g): X -> X$ in $Set$
  This means that $F$ picks out a set $X$ together with an (left) action of $G$ on $X$. Such a functor is called a (left)-$G$-set. A contravariant functor will define a right-$G$-set.
]

#example[
  A forgetful functor "forget some structure" from one category to another. For example,
  - $U: grp -> Set$ maps each group $G$ to the set $G$, and each group homomorphism to being set theoretic function between sets.
  - $U: sans("AbGrp") -> grp$ forgets the commutative structure, but keep the group structure.
  A free functor constructs free (the most general) objects. For example,
  - $F: Set -> grp$ maps each set $X$ to the free group generated by $X$.
]

#example[
  The contravariant power set functor $P: Set^op -> Set$ maps
  + each set $X$ to its power set $P(X)$
  + each function $f: X -> Y$ to the preimage function $P(f): P(Y) -> P(X)$ defined by $P(f)(S) = f^(-1)(S)$ for each subset $S subset.eq Y$.
  The contravariant open set functor $O: sans("Top")^op -> Set$ is defined similarly, mapping each topological space to its set of open sets.
]

#example[
  The contravariant dual vector space functor $(-)^*: vectk^op -> vectk$ maps
  + each vector space $V$ to its dual space $V^* = hom(V, k)$
  + each linear transformation $f: V -> W$ to the dual map $f^*: W^* -> V^*$ defined by $f^*(phi) = phi compose f$ for each $phi in W^* = (W -> k)$.
  functoriality is checked as $(f^* compose g^*)(phi) = (phi compose g) compose f = phi compose (g compose f) = (g compose f)^* (phi)$
]

#fancy.definition(title: "Hom functor")[
  The Hom functor $hom(A, -): calc -> Set$ or simply $h_A$ for a fixed object $A in calc$ maps
  + each object $X in calc$ to the hom set $hom(A, X)$. \ (explicit typing: $X -> (A -> X)$)
  + each morphism $f: X -> Y$ to the function 
  $ hom(A, f)&: hom(A, X) -> hom(A, Y) \ hom(A, f) &= f compose - $  (explicit typing: $(X -> Y) -> (A -> X) -> (A -> Y)$)

  Similarly, we have the contravariant Hom functor $h^X = hom(-, X): calc^op -> Set$ mapping each morphism $f: A -> B$ to the function 
  $ hom(f, X)&: hom(B, X) -> hom(A, X) \ hom(f, X) &= - compose f $
  We can write more compactly as $h_(A)(X), h_(A)(f), h^(X)(A), h^(X)(f)$.
]
#fancy.definition(title: "Product category")[
  Give two category $calc$ and $cal(D)$, their product category $calc times cal(D)$ consists of
  + objects: pairs $(c, d)$ where $c in calc$ and $d in cal(D)$
  + morphisms: pairs $(f, g): (c, d) -> (c', d')$ where $f: c -> c'$ in $calc$ and $g: d -> d'$ in $cal(D)$
  + composition: defined componentwise, $(f', g') compose (f, g) = (f' compose f, g' compose g)$
  + identities: $(id_c, id_d)$ for each object $(c, d)$
]
#definition(title: "Hom bifunctor")[
  Define $hom(-, -): calc^op times calc -> Set$ by
  + objects: $(A, X) mapsto hom(A, X)$
  + morphisms: for a pair $(f, h): (A' -> A, X -> X')$ maps to $hom(A, X) -> hom(A', X')$ by $g mapsto h compose g compose f$
]
#note-box[
  The image of $F: calc -> cal(D)$ is not necessarily a subcategory of $cal(D)$. Idea: when $c_1, c_2$ both map to the same object $d$, then for any two $c_1 -> c_2$, their images are both morphisms $d -> d$ which is composable, but the sources cannot be composed since they don't have matching domain and codomain.
]